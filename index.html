<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphabet Hearts - Big & Small Letters</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-image: url('https://i.postimg.cc/7YJBpKg3/Gemini_Generated_Image_4nb8h04nb8h04nb8.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding-bottom: 20px;
        }

        .jar-container {
            width: 600px;
            height: 780px;
            max-height: 90vh;
            max-width: 45vw;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            margin-bottom: 0px;
        }

        .jar-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            position: absolute;
            bottom: 0;
            z-index: 1;
        }

        .collected-hearts {
            position: absolute;
            bottom: 50px; 
            width: 60%;
            left: 20%;
            height: 65%;
            z-index: 10;
            pointer-events: none;
        }

        .jar-label {
            position: absolute;
            top: calc(5% - 20px); 
            background: #ffffff;
            padding: 12px 30px;
            border-radius: 30px;
            font-weight: 800;
            color: #db2777;
            border: 4px solid #f9a8d4;
            text-transform: uppercase;
            white-space: nowrap;
            z-index: 15;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            font-size: 1.2rem;
        }

        .heart {
            position: absolute;
            width: 95px;
            height: 95px;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            transition: transform 0.2s ease, filter 0.3s ease;
            touch-action: none;
        }

        .heart:active {
            cursor: grabbing;
        }

        @keyframes floatInside {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(8px, -10px) rotate(3deg); }
            50% { transform: translate(0px, -5px) rotate(0deg); }
            75% { transform: translate(-8px, 5px) rotate(-3deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        .heart.in-jar {
            position: absolute !important;
            transition: top 0.6s ease, left 0.6s ease;
            cursor: default;
            opacity: 0.85; 
            mix-blend-mode: multiply;
            animation: floatInside 6s ease-in-out infinite;
        }

        .heart-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('https://i.postimg.cc/qR1YMWFJ/Gemini_Generated_Image_iuou9fiuou9fiuou_2.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
        }

        .heart-text {
            position: relative;
            z-index: 21;
            font-weight: 800;
            color: white;
            font-size: 28px; /* Увеличил размер шрифта для букв */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
            pointer-events: none;
            padding: 10px;
            max-width: 85%;
            line-height: 1.1;
        }

        #ui-layer {
            position: absolute;
            top: 25px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        .score-board {
            background: white;
            padding: 12px 35px;
            border-radius: 50px;
            box-shadow: 0 8px 25px rgba(219, 39, 119, 0.2);
            font-size: 24px;
            font-weight: bold;
            color: #db2777;
            pointer-events: auto;
            border: 3px solid #fce7f3;
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            padding: 50px;
            border-radius: 40px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .btn {
            background: linear-gradient(135deg, #f472b6, #db2777);
            color: white;
            padding: 15px 45px;
            border-radius: 35px;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            margin-top: 25px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(3deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="score-board">Score: <span id="score">0</span> / 26</div>
    </div>

    <div id="game-container">
        <!-- Uppercase Jar -->
        <div id="jar-left" class="jar-container">
            <div class="jar-label">Uppercase</div>
            <div id="collected-left" class="collected-hearts"></div>
            <img src="https://i.postimg.cc/W4GRdvQV/Gemini-Generated-Image-bkkv0abkkv0abkkv.png" alt="Jar Left" class="jar-image">
        </div>

        <!-- Lowercase Jar -->
        <div id="jar-right" class="jar-container">
            <div class="jar-label">Lowercase</div>
            <div id="collected-right" class="collected-hearts"></div>
            <img src="https://i.postimg.cc/W4GRdvQV/Gemini-Generated-Image-bkkv0abkkv0abkkv.png" alt="Jar Right" class="jar-image">
        </div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2 class="text-4xl font-extrabold mb-6 text-pink-600">Fantastic!</h2>
            <p class="text-xl text-gray-600 mb-4">You sorted all 26 letters correctly!</p>
            <button class="btn" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script>
        // Генерируем буквы: Четные - Uppercase, Нечетные - Lowercase
        // СПЕЦИАЛЬНОЕ ПРАВИЛО: 
        // 1. Заменяем 'I' (которая была бы Uppercase) на 'B' (Uppercase), т.к. 'b' уже используется как lowercase.
        // 2. Заменяем 'l' (которая была бы Lowercase) на 'k' (Lowercase), т.к. 'K' уже используется как uppercase.
        
        const lettersData = [];
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        for (let i = 0; i < alphabet.length; i++) {
            const letter = alphabet[i];

            if (letter === 'I') {
                // Вместо I берем B (Большую), так как 'b' (маленькая) уже есть в наборе, 
                // но 'B' (большой) не было. Это позволяет избежать I.
                lettersData.push({ text: 'B', type: 'uppercase' });
            } else if (letter === 'L') {
                // Вместо l (маленькой L) берем k (маленькую k), так как 'K' (большая) есть в наборе,
                // а 'k' (маленькой) не было.
                lettersData.push({ text: 'k', type: 'lowercase' });
            } else {
                // Стандартная логика
                // Если индекс четный (0, 2, 4...) -> Uppercase (A, C, E...)
                // Если индекс нечетный (1, 3, 5...) -> Lowercase (b, d, f...)
                if (i % 2 === 0) {
                    lettersData.push({ text: letter.toUpperCase(), type: 'uppercase' });
                } else {
                    lettersData.push({ text: letter.toLowerCase(), type: 'lowercase' });
                }
            }
        }

        let score = 0;
        const placedPositions = {
            left: [],
            right: []
        };

        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const jarLeft = document.getElementById('jar-left');
        const jarRight = document.getElementById('jar-right');
        const collectedLeft = document.getElementById('collected-left');
        const collectedRight = document.getElementById('collected-right');
        const modal = document.getElementById('modal');

        const HEART_SIZE = 140; 
        const MIN_DIST = 110; 

        // Звуки
        const correctSound = new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg'); 
        const wrongSound = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
        
        correctSound.volume = 0.25;
        wrongSound.volume = 0.25;

        function initHearts() {
            // Перемешиваем и создаем
            lettersData.sort(() => Math.random() - 0.5).forEach(data => createHeart(data));
        }

        function createHeart(data) {
            const heart = document.createElement('div');
            heart.className = 'heart';
            
            const offsetX = window.innerWidth / 2 - 70;
            const offsetY = window.innerHeight / 2 - 20;
            
            const startX = offsetX + (Math.random() - 0.5) * (window.innerWidth * 0.3);
            const startY = offsetY + (Math.random() - 0.5) * (window.innerHeight * 0.4);
            
            heart.style.left = startX + 'px';
            heart.style.top = startY + 'px';
            heart.style.animation = `float ${3 + Math.random() * 2}s ease-in-out infinite`;

            heart.innerHTML = `
                <div class="heart-bg"></div>
                <div class="heart-text">${data.text}</div>
            `;

            container.appendChild(heart);
            makeDraggable(heart, data);
        }

        function makeDraggable(element, data) {
            let isDragging = false;
            let currentX = 0, currentY = 0, initialX, initialY;
            let xOffset = 0, yOffset = 0;

            const startEvents = ['mousedown', 'touchstart'];
            const moveEvents = ['mousemove', 'touchmove'];
            const endEvents = ['mouseup', 'touchend'];

            startEvents.forEach(evt => element.addEventListener(evt, dragStart, {passive: false}));

            function dragStart(e) {
                if (element.classList.contains('in-jar')) return;

                if (e.type === "touchstart") {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }
                
                if (e.target === element || element.contains(e.target)) {
                    isDragging = true;
                    element.style.animation = 'none';
                    element.style.zIndex = 1000;
                    
                    moveEvents.forEach(evt => document.addEventListener(evt, drag, {passive: false}));
                    endEvents.forEach(evt => document.addEventListener(evt, dragEnd));
                }
            }

            function dragEnd() {
                if (!isDragging) return;
                isDragging = false;
                
                moveEvents.forEach(evt => document.removeEventListener(evt, drag));
                endEvents.forEach(evt => document.removeEventListener(evt, dragEnd));

                if (!checkDrop(element, data)) {
                    element.style.transition = "all 0.5s ease";
                    element.style.transform = "translate3d(0, 0, 0)";
                    xOffset = 0;
                    yOffset = 0;
                    setTimeout(() => {
                        element.style.transition = "transform 0.2s ease";
                        element.style.animation = `float 3s ease-in-out infinite`;
                        element.style.zIndex = 20;
                    }, 500);
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    let clientX = e.type === "touchmove" ? e.touches[0].clientX : e.clientX;
                    let clientY = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;

                    currentX = clientX - initialX;
                    currentY = clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    element.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                }
            }
        }

        function checkDrop(element, data) {
            const rect = element.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const leftJarRect = jarLeft.getBoundingClientRect();
            const rightJarRect = jarRight.getBoundingClientRect();

            const inLeft = centerX > leftJarRect.left && centerX < leftJarRect.right && 
                           centerY > leftJarRect.top && centerY < leftJarRect.bottom;
                           
            const inRight = centerX > rightJarRect.left && centerX < rightJarRect.right && 
                            centerY > rightJarRect.top && centerY < rightJarRect.bottom;

            // Логика проверки: Uppercase -> Left Jar, Lowercase -> Right Jar
            if (inLeft && data.type === 'uppercase') {
                moveToJar(element, 'left');
                return true;
            } else if (inRight && data.type === 'lowercase') {
                moveToJar(element, 'right');
                return true;
            }
            
            if (inLeft || inRight) {
                // Ошибка
                wrongSound.currentTime = 0;
                wrongSound.play().catch(e => console.log("Audio play error:", e));

                element.style.filter = "brightness(0.7) sepia(1) hue-rotate(-50deg)";
                setTimeout(() => element.style.filter = "none", 500);
            }
            return false;
        }

        function findEmptySpot(jarKey, jarContainer) {
            const w = jarContainer.offsetWidth - HEART_SIZE;
            const h = jarContainer.offsetHeight - HEART_SIZE;
            
            const existing = placedPositions[jarKey];
            let bestX, bestY;
            let minOverlap = Infinity;

            for (let i = 0; i < 150; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                let currentMaxOverlap = 0;

                for (const pos of existing) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                    if (dist < MIN_DIST) { 
                        currentMaxOverlap = Math.max(currentMaxOverlap, MIN_DIST - dist);
                    }
                }

                if (currentMaxOverlap === 0) {
                    existing.push({x, y});
                    return {x, y};
                }

                if (currentMaxOverlap < minOverlap) {
                    minOverlap = currentMaxOverlap;
                    bestX = x;
                    bestY = y;
                }
            }

            existing.push({x: bestX, y: bestY});
            return {x: bestX, y: bestY};
        }

        function moveToJar(element, jarKey) {
            correctSound.currentTime = 0;
            correctSound.play().catch(e => console.log("Audio play error:", e));

            score++;
            scoreElement.innerText = score;
            
            const jarContainer = jarKey === 'left' ? collectedLeft : collectedRight;
            const spot = findEmptySpot(jarKey, jarContainer);

            element.classList.add('in-jar');
            jarContainer.appendChild(element);
            
            element.style.removeProperty('transform'); 
            element.style.transition = "none";
            element.style.left = spot.x + 'px';
            element.style.top = spot.y + 'px';
            element.style.zIndex = 15;
            
            element.style.animationDelay = (Math.random() * -5) + 's';

            if (score === 26) {
                setTimeout(() => modal.style.display = 'flex', 800);
            }
        }

        window.onload = initHearts;
    </script>
</body>
</html>